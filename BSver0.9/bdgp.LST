C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 1   


C166 COMPILER V7.53.0.0, COMPILATION OF MODULE BDGP
OBJECT MODULE PLACED IN bdgp.OBJ
COMPILER INVOKED BY: C:\Keil\C166\BIN\C166.EXE bdgp.c XLARGE BROWSE MOD167 DEBUG TABS(2) 

 stmt lvl     source

    1         #include "bdgp.h"
    2         #include "can.h"
    3         #include "process.h"
    4         #include "protocol.h"
    5         #include "float.h"
    6         
    7         #include "settings.h"
    8         
    9         static float fLikelihoods[360];
   10         static float fAngleDiagramm[48];
   11         static uint8  msgCounterBDGP = 0;
   12         
   13         
   14         
   15         const uint8   startBDGPMsg[] = {0x40};
   16         const uint8   stopBDGPMsg[] = {0x41};
   17         const uint8   resetBDGPMsg[] = {0x42};
   18         //–¥–ª—è –≥—Ä–∞–Ω–∞—Ç—ã
   19         /*
   20         const float directionCoef[] = {
   21         1.0f,
   22         0.999996f,
   23         0.999982f,
   24         0.999961f,
   25         0.99993f,
   26         0.99989f,
   27         0.999842f,
   28         0.999785f,
   29         0.99972f,
   30         0.999646f,
   31         0.999563f,
   32         0.999471f,
   33         0.999371f,
   34         0.999262f,
   35         0.999145f,
   36         0.99902f,
   37         0.998886f,
   38         0.998743f,
   39         0.998592f,
   40         0.998433f,
   41         0.998266f,
   42         0.998091f,
   43         0.997907f,
   44         0.997716f,
   45         0.997516f,
   46         0.997309f,
   47         0.997094f,
   48         0.996871f,
   49         0.99664f,
   50         0.996402f,
   51         0.996156f,
   52         0.995903f,
   53         0.995643f,
   54         0.995375f,
   55         0.9951f,
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 2   

   56         0.994818f,
   57         0.99453f,
   58         0.994234f,
   59         0.993932f,
   60         0.993623f,
   61         0.993307f,
   62         0.992985f,
   63         0.992657f,
   64         0.992322f,
   65         0.991982f,
   66         0.991635f,
   67         0.991283f,
   68         0.990924f,
   69         0.990561f,
   70         0.990191f,
   71         0.989817f,
   72         0.989437f,
   73         0.989052f,
   74         0.988662f,
   75         0.988267f,
   76         0.987868f,
   77         0.987464f,
   78         0.987055f,
   79         0.986642f,
   80         0.986225f,
   81         0.985804f,
   82         0.985379f,
   83         0.98495f,
   84         0.984518f,
   85         0.984082f,
   86         0.983643f,
   87         0.983201f,
   88         0.982755f,
   89         0.982307f,
   90         0.981856f,
   91         0.981402f,
   92         0.980946f,
   93         0.980487f,
   94         0.980027f,
   95         0.979564f,
   96         0.9791f,
   97         0.978633f,
   98         0.978165f,
   99         0.977696f,
  100         0.977225f,
  101         0.976754f,
  102         0.976281f,
  103         0.975807f,
  104         0.975333f,
  105         0.974858f,
  106         0.974383f,
  107         0.973907f,
  108         0.973432f,
  109         0.972956f,
  110         0.972481f,
  111         0.972005f,
  112         0.971531f,
  113         0.971057f,
  114         0.970583f,
  115         0.970111f,
  116         0.96964f,
  117         0.969169f,
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 3   

  118         0.968701f,
  119         0.968233f,
  120         0.967767f,
  121         0.967303f,
  122         0.966841f,
  123         0.966381f,
  124         0.965923f,
  125         0.965467f,
  126         0.965013f,
  127         0.964563f,
  128         0.964114f,
  129         0.963669f,
  130         0.963227f,
  131         0.962787f,
  132         0.962351f,
  133         0.961918f,
  134         0.961488f,
  135         0.961062f,
  136         0.96064f,
  137         0.960222f,
  138         0.959807f,
  139         0.959396f,
  140         0.95899f,
  141         0.958588f,
  142         0.952701f,
  143         0.935417f,
  144         0.912921f,
  145         0.886712f,
  146         0.8575f,
  147         0.825714f,
  148         0.791644f,
  149         0.755501f,
  150         0.71745f,
  151         0.67762f,
  152         0.63612f,
  153         0.593042f,
  154         0.548465f,
  155         0.50246f,
  156         0.455088f,
  157         0.406407f,
  158         0.356468f,
  159         0.30532f,
  160         0.253008f,
  161         0.209271f,
  162         0.183096f,
  163         0.163388f,
  164         0.147567f,
  165         0.134443f,
  166         0.123329f,
  167         0.113776f,
  168         0.105474f,
  169         0.098197f,
  170         0.091773f,
  171         0.086069f,
  172         0.080979f,
  173         0.07642f,
  174         0.07232f,
  175         0.068624f,
  176         0.065283f,
  177         0.062256f,
  178         0.059509f,
  179         0.057013f,
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 4   

  180         0.054743f,
  181         0.052676f,
  182         0.050794f,
  183         0.049079f,
  184         0.047519f,
  185         0.046099f,
  186         0.04481f,
  187         0.04364f,
  188         0.042583f,
  189         0.041629f,
  190         0.040773f,
  191         0.040008f,
  192         0.03933f,
  193         0.038735f,
  194         0.038217f,
  195         0.037775f,
  196         0.037406f,
  197         0.037106f,
  198         0.036875f,
  199         0.036711f,
  200         0.036613f,
  201         0.036581f
  202         };*/
  203         //–¥–ª—è —Å–ø–µ–∫—Ç—Ä–æ–º–µ—Ç—Ä–∞
  204         const float directionCoef[] = {
  205         1.0000,
  206         1.0000,
  207         1.0000,
  208         0.99949,
  209         0.9961,
  210         0.9948,
  211         0.99357,
  212         0.99241,
  213         0.9913,
  214         0.99025,
  215         0.98925,
  216         0.98829,
  217         0.98736,
  218         0.98647,
  219         0.9856,
  220         0.98474,
  221         0.9839,
  222         0.98307,
  223         0.98224,
  224         0.98141,
  225         0.98057,
  226         0.97971,
  227         0.97884,
  228         0.97794,
  229         0.97701,
  230         0.97604,
  231         0.97504,
  232         0.97399,
  233         0.97289,
  234         0.97174,
  235         0.97053,
  236         0.96925,
  237         0.96791,
  238         0.96649,
  239         0.965,
  240         0.96343,
  241         0.96177,
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 5   

  242         0.96002,
  243         0.95817,
  244         0.95623,
  245         0.95419,
  246         0.95204,
  247         0.94978,
  248         0.9474,
  249         0.94491,
  250         0.9423,
  251         0.93956,
  252         0.93669,
  253         0.93369,
  254         0.93056,
  255         0.92728,
  256         0.92387,
  257         0.92031,
  258         0.9166,
  259         0.91274,
  260         0.90872,
  261         0.90455,
  262         0.90021,
  263         0.89571,
  264         0.89105,
  265         0.88621,
  266         0.88121,
  267         0.87603,
  268         0.87067,
  269         0.86514,
  270         0.85942,
  271         0.85352,
  272         0.84744,
  273         0.84116,
  274         0.8347,
  275         0.82804,
  276         0.82119,
  277         0.81414,
  278         0.8069,
  279         0.79945,
  280         0.79181,
  281         0.78396,
  282         0.7759,
  283         0.76764,
  284         0.75917,
  285         0.7505,
  286         0.74161,
  287         0.73251,
  288         0.7232,
  289         0.71368,
  290         0.70394,
  291         0.69398,
  292         0.68381,
  293         0.67342,
  294         0.66281,
  295         0.65198,
  296         0.64094,
  297         0.62967,
  298         0.61818,
  299         0.60647,
  300         0.59454,
  301         0.58239,
  302         0.57002,
  303         0.55742,
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 6   

  304         0.54461,
  305         0.53522,
  306         0.52851,
  307         0.51786,
  308         0.50698,
  309         0.49591,
  310         0.48469,
  311         0.47337,
  312         0.46199,
  313         0.45058,
  314         0.43919,
  315         0.42785,
  316         0.41658,
  317         0.40543,
  318         0.39442,
  319         0.38358,
  320         0.37293,
  321         0.36251,
  322         0.35233,
  323         0.3424,
  324         0.33276,
  325         0.32342,
  326         0.3144,
  327         0.3057,
  328         0.29734,
  329         0.28933,
  330         0.28168,
  331         0.27439,
  332         0.26748,
  333         0.26093,
  334         0.25476,
  335         0.24897,
  336         0.24354,
  337         0.23848,
  338         0.23378,
  339         0.22943,
  340         0.22543,
  341         0.22176,
  342         0.21841,
  343         0.21537,
  344         0.21261,
  345         0.21013,
  346         0.20789,
  347         0.20589,
  348         0.20409,
  349         0.20247,
  350         0.201,
  351         0.19965,
  352         0.1984,
  353         0.19721,
  354         0.19605,
  355         0.193825,
  356         0.19206,
  357         0.19145,
  358         0.19095,
  359         0.19054,
  360         0.19022,
  361         0.18997,
  362         0.1898,
  363         0.18968,
  364         0.18962,
  365         0.1896,
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 7   

  366         0.18963,
  367         0.18969,
  368         0.18977,
  369         0.18988,
  370         0.19,
  371         0.19013,
  372         0.19027,
  373         0.19041,
  374         0.19055,
  375         0.19068,
  376         0.19081,
  377         0.19092,
  378         0.19102,
  379         0.19111,
  380         0.19118,
  381         0.19122,
  382         0.19125,
  383         0.19126,
  384         0.19125,
  385         0.19122
  386         };
  387         
  388         static tBDGPData      BDGPData;
  389         static tBDGPParametrs BDGPParametrs[2];
  390         
  391         static float      doseArray[SLIDER_SIZE];
  392         
  393         static uint8      sliderCounter = 0;
  394         static uint8      dynamicMode = 0;
  395         static uint8      sliderMax = 0;
  396         static uint8      currentRangeIndex = 0;  //–Ω–æ–º–µ—Ä —Ç–µ–∫—É—â–µ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
  397         
  398         uint16  BDGP_MinCounter()
  399         {
  400  1        uint8   i = 0;
  401  1        uint16  result = 0xFFFF;
  402  1        
  403  1          for(i = 0;i<SENSORS;i++){
  404  2            if(BDGPData.WorkData[i] < result)
  405  2              result = BDGPData.WorkData[i];
  406  2          }
  407  1        return result;
  408  1      }
  409         uint16  BDGP_MaxCounter()
  410         {
  411  1        uint8   i = 0;
  412  1        uint16  result = 0;
  413  1        
  414  1          for(i = 0;i<SENSORS;i++){
  415  2            if(BDGPData.WorkData[i] > result)
  416  2              result = BDGPData.WorkData[i];
  417  2          }
  418  1        return result;
  419  1      }
  420         
  421         float BDGP_MinSumSensData()
  422         {
  423  1        uint8 i = 0;
  424  1        float result = FLT_MAX;
  425  1          for(i = 0;i<SENSORS;i++){
  426  2            if(BDGPData.fCorrectionSumSensData[i] < result)
  427  2              result = BDGPData.fCorrectionSumSensData[i];
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 8   

  428  2          }
  429  1        return result;
  430  1      }
  431         float BDGP_MaxSumSensData()
  432         {
  433  1        uint8 i = 0;
  434  1        float result = FLT_MIN;
  435  1          for(i = 0;i<SENSORS;i++){
  436  2            if(BDGPData.fCorrectionSumSensData[i] > result)
  437  2              result = BDGPData.fCorrectionSumSensData[i];
  438  2          }
  439  1        return result;
  440  1      }
  441         
  442         void  BDGP_Reset()
  443         {
  444  1        msgCounterBDGP = 0;
  445  1        sliderCounter = 0;
  446  1        dynamicMode = 0;
  447  1        sliderMax = 0;
  448  1        
  449  1        memset(doseArray,0,sizeof(float) * SLIDER_SIZE);
  450  1        memset((uint8*)&BDGPData,0,sizeof(tBDGPData));
  451  1        memset((uint8*)&BDGPParametrs,0,sizeof(tBDGPParametrs) * 2);
  452  1        
  453  1        CAN_SendMessage(CAN_BDGP_CMD_TX,resetBDGPMsg,1);
  454  1        
  455  1        
  456  1      
  457  1      }
  458         
  459         
  460         /*
  461         –§–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ CAN —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ –∑–∞–ø—Ä–æ—Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏–∑ –ë–î
  462           range - 1,2 / –¥–∏–∞–ø–∞–∑–æ–Ω—ã –±–ª–æ–∫–∞ –ë–î–ì–ü
  463           paramIndex - –ò–î –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
  464           paramSubIndex - –°—É–±–∏–Ω–¥–µ–∫—Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
  465         */
  466         void  BDGP_ParametrRequest(uint8  range,uint8 paramIndex,uint8  paramSubIndex)
  467         {
  468  1        uint16  canID = 0x222 + range;
  469  1        
  470  1        uint8 Data[8];
  471  1          
  472  1          memset((uint8*)Data,0,sizeof(uint8) * 8);
  473  1          
  474  1          Data[0] = 0x05;
  475  1          Data[1] = paramIndex;
  476  1          Data[2] = 0x00;
  477  1          Data[3] = paramSubIndex;
  478  1        
  479  1        CAN_SendMessage(canID,Data,8);
  480  1      }
  481         /*
  482         –§-–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ CAN —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ –∑–∞–ø–∏—Å—å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤ –ë–î
  483           range - 1,2 –¥–∏–∞–ø–∞–∑–æ–Ω—ã –±–ª–æ–∫ –ë–î–ì–ü
  484           paramIndex - –∏–Ω–¥–µ–∫—Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
  485           paramSubIndex - —Å—É–±–∏–Ω–¥–µ–∫—Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
  486           *pParam - —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –¥–∞–Ω–Ω—ã–µ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º
  487           dataSize - —Ä–∞–º–µ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
  488         */
  489         void BDGP_WriteParametr(uint8 range,uint8 paramIndex,uint8 paramSubIndex, uint8 *pParam,int dataSize)
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 9   

  490         {
  491  1        uint16  canID = 0x222 + range;
  492  1        uint8 Data[8];
  493  1        
  494  1          memset((uint8*)Data,0,sizeof(uint8) * 8);
  495  1        
  496  1          Data[0] = 0x04;
  497  1          Data[1] = paramIndex;
  498  1          Data[2] = 0x00;
  499  1          Data[3] = paramSubIndex;
  500  1        
  501  1          memcpy(Data + 4,(uint32*)(pParam),dataSize);
  502  1        
  503  1        CAN_SendMessageIT(canID,Data,8);
  504  1          
  505  1      }
  506         //–∑–∞–ø—É—Å–∫ –∑–∞–ø–∏—Å–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤ –ë–î
  507         void  BDGP_StartWritingParametrs(uint8  rangeIndex)
  508         {
  509  1        BDGP_WriteParametr(1 + rangeIndex,0x93,0,(uint8*)&BDGPParametrs[0].fCorrectionFactors[0],sizeof(float));
  510  1      }
  511         
  512         void  BDGP_Start()
  513         {
  514  1        CAN_SendMessage(CAN_BDGP_CMD_TX,startBDGPMsg,1);
  515  1      }
  516         void  BDGP_ForcedStart(uint8  rangeNumber)
  517         {
  518  1        uint8 pData[2];
  519  1        
  520  1      
  521  1          pData[0] = 0x40;
  522  1          pData[1] = rangeNumber;
  523  1        
  524  1        CAN_SendMessage(CAN_BDGP_CMD_TX,pData,2);
  525  1      }
  526         
  527         void  BDGP_Stop()
  528         {
  529  1        CAN_SendMessage(CAN_BDGP_CMD_TX,stopBDGPMsg,1);
  530  1      }
  531         
  532         void  BDGP_InsertParametrs(uint16 regID,uint8 *pData)
  533         {
  534  1        uint32  rangesPack = 0;
  535  1        uint8   rangeIndex = 0;
  536  1      
  537  1          if(regID == 0x423) rangeIndex = 0;
  538  1          else if(regID == 0x424) rangeIndex = 1;
  539  1          else return;
  540  1        
  541  1        //–∑–∞–ø—Ä–æ—Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
  542  1        if(pData[0] == 0x05)
  543  1        {
  544  2          switch(pData[1])
  545  2          {
  546  3            case 0x93:
  547  3            {
  548  4              memcpy((uint8*)&BDGPParametrs[rangeIndex].fCorrectionFactors[pData[3]],(pData + 4),4);
  549  4              
  550  4                if(pData[3]<12){
  551  5                  BDGP_ParametrRequest(rangeIndex + 1,0x93,pData[3]+1);
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 10  

  552  5                }
  553  4                else
  554  4                  BDGP_ParametrRequest(rangeIndex + 1,0x94,0);
  555  4                
  556  4              
  557  4            }break;
  558  3            
  559  3            case 0x94:
  560  3            {
  561  4                memcpy((uint8*)&BDGPParametrs[rangeIndex].fDeadTime,(pData + 4),4);
  562  4                  BDGP_ParametrRequest(rangeIndex + 1,0x95,0);
  563  4            }break;
  564  3            
  565  3            case 0x95:
  566  3            {
  567  4              memcpy((uint8*)&BDGPParametrs[rangeIndex].fEffectCounters,(pData + 4),4);
  568  4                  BDGP_ParametrRequest(rangeIndex + 1,0x96,0);
  569  4            }break;
  570  3            
  571  3            case 0x96:
  572  3            {
  573  4              memcpy((uint8*)&BDGPParametrs[rangeIndex].fSensCounters,(pData + 4),4);
  574  4                  BDGP_ParametrRequest(rangeIndex + 1,0x97,0);
  575  4            }break;
  576  3            
  577  3            case 0x97:
  578  3            {
  579  4              memcpy((uint8*)&BDGPParametrs[rangeIndex].rangeMin,pData + 4,2);
  580  4              memcpy((uint8*)&BDGPParametrs[rangeIndex].rangeMax,pData + 6,2);
  581  4                //–∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Å–æ –≤—Ç–æ—Ä–æ–≥–æ —ç—Ç–∞–∂–∞ –ë–î
  582  4                if(rangeIndex == 0)
  583  4                  BDGP_ParametrRequest( 2,0x93,0);
  584  4            }break;
  585  3          }
  586  2        }
  587  1        //–∑–∞–¥–∞–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
  588  1        if(pData[0] == 0x04)
  589  1        {
  590  2          switch(pData[1])
  591  2          {
  592  3            case 0x93:
  593  3            {
  594  4                if(pData[3]<12){
  595  5                  BDGP_WriteParametr(rangeIndex + 1,0x93,pData[3] + 1,(uint8*)&BDGPParametrs[rangeIndex].fCorrectionFa
             -ctors[pData[3] + 1],sizeof(float));
  596  5                  
  597  5                }
  598  4                else
  599  4                  BDGP_WriteParametr(rangeIndex + 1,0x94,0,(uint8*)&BDGPParametrs[rangeIndex].fDeadTime,sizeof(float))
             -;
  600  4            }break;
  601  3            
  602  3            case 0x94:
  603  3            {
  604  4              BDGP_WriteParametr(rangeIndex + 1,0x95,0,(uint8*)&BDGPParametrs[rangeIndex].fEffectCounters,sizeof(flo
             -at));
  605  4            }break;
  606  3            
  607  3            case 0x95:
  608  3            {
  609  4              BDGP_WriteParametr(rangeIndex + 1,0x96,0,(uint8*)&BDGPParametrs[rangeIndex].fSensCounters,sizeof(float
             -));
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 11  

  610  4            }break;
  611  3            
  612  3            case 0x96:
  613  3            {
  614  4              rangesPack = BDGPParametrs[rangeIndex].rangeMax; 
  615  4              rangesPack = rangesPack << 16;
  616  4              rangesPack = rangesPack|BDGPParametrs[rangeIndex].rangeMin;
  617  4                
  618  4      
  619  4                BDGP_WriteParametr(rangeIndex + 1,0x97,0,(uint8*)&rangesPack,sizeof(float));
  620  4            }break;
  621  3            
  622  3            case 0x97:
  623  3            {
  624  4              if(rangeIndex == 0)
  625  4                BDGP_StartWritingParametrs(1);
  626  4              else//—Ç—É—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ–º
  627  4              {
  628  5                BDGP_WriteParametr(1,0xE0,0xFF,0,0);
  629  5                BDGP_WriteParametr(2,0xE0,0xFF,0,0);
  630  5                
  631  5              }
  632  4                
  633  4              
  634  4            }break;
  635  3          }
  636  2        }
  637  1      
  638  1      }
  639         /*
  640         –§-–∏—è –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–µ–æ –≤ —Ä–µ–∂–∏–º–µ —à—Ç–∞—Ç–Ω–æ–π —Ä–∞–±–
             -æ—Ç—ã –∏ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Å–ø–µ–∫—Ç—Ä–æ–º–µ—Ç—Ä–∞
  641         */
  642         void  BDGP_BackgroundAccumulation(uint16  *pData)
  643         {
  644  1        uint8   i = 0;
  645  1        
  646  1        float fCurrentData = 0; 
  647  1        
  648  1        if(BDGPData.BackgroundIndex < BACKGROUND_TIME){
  649  2          for(i = 0;i<SENSORS;i++){
  650  3            fCurrentData = ((pData[i] * BDGPParametrs[currentRangeIndex].fCorrectionFactors[i]) / (1.0f - pData[i] 
             -* BDGPParametrs[currentRangeIndex].fDeadTime));
  651  3            
  652  3            BDGPData.BackgroundAverageSpeed += fCurrentData;
  653  3          }
  654  2          BDGPData.BackgroundAverageDose += BDGPData.currentDose;
  655  2          BDGPData.BackgroundIndex++;
  656  2        }
  657  1        if((BDGPData.Background == 0) && (BDGPData.BackgroundIndex == BACKGROUND_TIME) ){
  658  2          BDGPData.Background = 1;  
  659  2          BDGPData.BackgroundAverageSpeed = BDGPData.BackgroundAverageSpeed / BACKGROUND_TIME;
  660  2          BDGPData.BackgroundAverageDose = BDGPData.BackgroundAverageDose / BACKGROUND_TIME;
  661  2          
  662  2              IMDB_SendPacket(IMDB_SEND_BACKGROUND_SUCCESS,(uint8*)&BDGPData.BackgroundAverageDose,sizeof(float));//
             -–æ—Ç—Å—ã–ª–∞–µ–º —É—Å–ø–µ—Ö –≤ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–∏ —Ñ–æ–Ω–∞
  663  2              Process_SetStatus(IMDB_FULLTIME_WORK);//–ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –≤ —Ä–µ–∂–∏–º —à—Ç–∞—Ç–Ω–æ–π —Ä–∞–±
             -–æ—Ç—ã
  664  2        }
  665  1          
  666  1      }
  667         void  BDGP_ResetBackgroundData()
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 12  

  668         {
  669  1        BDGPData.BackgroundAverageSpeed = 0;
  670  1        BDGPData.BackgroundAverageDose = 0;
  671  1        
  672  1        BDGPData.BackgroundIndex = 0;
  673  1        BDGPData.Background = 0;
  674  1      }
  675         
  676         void  BDGP_InsertDataNew(uint16 regID,uint8 *pData)
  677         {
  678  1        uint8 activeBuffer = BDGPData.ActiveBuffer;
  679  1        
  680  1        if(pData[0] == 0x40 && pData[1] == 0xFF)//–ø–æ–π–º–∞–ª–∏ –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
  681  1        {
  682  2          //–æ–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–º–µ—Ä –¥–∏–∞–ø–∞–∑–æ–Ω–∞
  683  2          if(regID == 0x723)
  684  2            currentRangeIndex = 0;
  685  2          if(regID == 0x724)
  686  2            currentRangeIndex = 1;
  687  2          //–∫–æ–ø–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –ú–î –∏ —Å—Ä–µ–¥–Ω–µ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å—á—ë—Ç–∞
  688  2          memcpy((uint8*)&BDGPData.counterRate,(uint8*)pData+2,sizeof(uint16));
  689  2          memcpy((uint8*)&BDGPData.currentDose,(uint8*)pData+4,sizeof(float));
  690  2          
  691  2          msgCounterBDGP = 0;
  692  2        }
  693  1        else
  694  1        {
  695  2          BDGPData.InputData[activeBuffer][msgCounterBDGP * 4]       = (uint16)((pData[1] << 8) | pData[0]);
  696  2          BDGPData.InputData[activeBuffer][(msgCounterBDGP * 4) + 1] = (uint16)((pData[3] << 8) | pData[2]);
  697  2          BDGPData.InputData[activeBuffer][(msgCounterBDGP * 4) + 2] = (uint16)((pData[5] << 8) | pData[4]);
  698  2          BDGPData.InputData[activeBuffer][(msgCounterBDGP * 4) + 3] = (uint16)((pData[7] << 8) | pData[6]);
  699  2          
  700  2          msgCounterBDGP++;
  701  2          /*
  702  2          //–∫–æ–ø–∏—Ä—É–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å—á—ë—Ç–∞ —Ç–µ–∫—É—â–µ–≥–æ –ø–∞–∫–µ—Ç–∞ —Å –¥–∞–Ω–Ω—ã–º–∏
  703  2          memcpy((uint16*)BDGPData.sensorsCntCopy + (msgCounterBDGP * 4),(uint8*)pData,sizeof(uint16) * 4);
  704  2          
  705  2          msgCounterBDGP++;
  706  2          //–µ—Å–∏–ª –ø–æ–ª—É—á–∏–ª–∏ –≤—Å–µ –ø–∞–∫–µ—Ç—ã —Å–æ —Å–∫–æ—Ä–æ—Å—Ç—è–º–∏, —Ç–æ –∫–æ–ø–∏—Ä—É–µ–º –∏—Ö –≤
             - —Ä–∞–±–æ—á–∏–π –º–∞—Å—Å–∏–≤
  707  2          if(msgCounterBDGP == 3){
  708  2            memcpy((uint8*)BDGPData.sensorsCnt,(uint8*)BDGPData.sensorsCntCopy,sizeof(uint16) * SENSORS);
  709  2            
  710  2            BDGPData.CanPackageEvent = 1;
  711  2          }*/
  712  2            if(msgCounterBDGP == 3){
  713  3              if(BDGPData.ActiveBuffer == 1)
  714  3                BDGPData.ActiveBuffer = 0;
  715  3              else
  716  3                BDGPData.ActiveBuffer = 1;
  717  3              
  718  3              BDGPData.ChangeBufferEvent = 1;
  719  3            }
  720  2        }
  721  1      }
  722         
  723         void  BDGP_InsertCmd(uint8  *pData)
  724         {
  725  1        if(pData[0] == 0x42)
  726  1        {
  727  2          Process_BDGPStatus(DEVICE_READY);
  728  2          
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 13  

  729  2          //–∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±–ª–æ–∫–∞ 1 –¥–∏–∞–ø–∞–∑–æ–Ω, –∫–æ—ç—Ñ–∏—Ü–∏–µ–Ω—Ç—ã, —Å—É–
             -±–∏–Ω–¥–µ–∫—Å - –ø–µ—Ä–≤—ã–π –∫–æ—ç—Ñ–∏—Ü–µ–Ω—Ç
  730  2          BDGP_ParametrRequest(1,0x93,0);
  731  2        }
  732  1      }
  733         float BDGP_GetAverageDoseRate()
  734         {
  735  1        return BDGPData.averageDose;
  736  1      }
  737         float   BDGP_GetCurrentDoseRate()
  738         {
  739  1        return BDGPData.currentDose;
  740  1      }
  741         
  742         uint8 *BDGP_GetParametrs()
  743         {
  744  1        return (uint8*)&BDGPParametrs;
  745  1      }
  746         
  747         float *BDGP_DirectionDiagramm(float *pData, uint8 SensCount, float cntMin,float cntMax, uint16  *pAngleMax,
             - eAngDiagrammMode Mode)
  748         {
  749  1        //float correctionData[SENSORS];
  750  1        uint16  lIndex[SENSORS];
  751  1        int16 f = 0,g = 0,b = 0;
  752  1        uint8   i = 0,j = 0;
  753  1        
  754  1        //uint16  cntMin = BDGP_MinCounter();
  755  1        //uint16  cntMax = BDGP_MaxCounter();
  756  1        float fK = 0.8f - ((cntMin + 1) / (cntMax + 1));  //–∫–æ—ç—Ñ. —Ä–∞–∑—Ä—ã—Ö–ª–µ–Ω–∏—è –∂–æ–ø—ã
  757  1        float fZ = 0.0f;
  758  1        
  759  1        float SignalLevel = (cntMax - cntMin) / (1 - directionCoef[180]);
  760  1        float BackLevel = (cntMin - directionCoef[180] * cntMax) / (1 - directionCoef[180]);
  761  1          
  762  1        //float *fLikelihoods = (float*)malloc(sizeof(float)*360);
  763  1        //float *fAngleDiagramm = (float*)malloc(sizeof(float)*49);
  764  1        
  765  1        float fLHMin = FLT_MAX; //–º–∏–Ω–∏–º—É–º —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–∞–≤–¥–æ–ø–æ–¥–æ–±–∏—è
  766  1        float fLHMax = FLT_MIN; //–º–∞–∫—Å–∏–º—É–º —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–∞–≤–¥–æ–ø–æ–¥–æ–±–∏—è
  767  1        float fNLMax = -100000;//FLT_MIN; //–º–∞–∫—Å–∏–º—É–º —Å–∂–∞—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
  768  1        float fNormizeKoef = 0.0f;  //–∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –Ω–æ—Ä–º–∏—Ä–æ–≤–∫–∏
  769  1        float fCountersSum = 0.0f;  //—Å—É–º–º–∞ —Å—á–µ—Ç–æ–≤ —Å—á—ë—Ç—á–∏–∫–æ–≤ –ë–î –∑–∞ –≤—Ä–µ–º—è –¥–≤–∏–∂–∫–∞
  770  1        float fLLSum = 0;
  771  1        
  772  1        float fLog = 0; //–ø–æ–¥–ª–æ–≥–∞—Ä–∏—Ñ–º. —Ñ—É–Ω–∫—Ü–∏—è
  773  1        float fFullLog = 0;
  774  1        
  775  1        memset(fAngleDiagramm,0,sizeof(float) * 48);
  776  1        
  777  1        //–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ —Å–∫–æ—Ä–æ—Å—Ç–µ–π —Å—á—ë—Ç–∞
  778  1        if(BackLevel <= 0.0f)
  779  1          BackLevel = 0.1f;
  780  1        if(SignalLevel <= 0.0f)
  781  1          SignalLevel = 1.0f;
  782  1        
  783  1        fLog = (SignalLevel / BackLevel);
  784  1        
  785  1        //if(fLikelihoods)
  786  1        {
  787  2      
  788  2        
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 14  

  789  2          for(f = 0;f<360;f++)
  790  2          {
  791  3            for(i = 0;i<SensCount;i++)
  792  3            {
  793  4              if( abs(-f + (30 * i)) < 181)
  794  4              {
  795  5                lIndex[i] = abs(-f + (30 * i));
  796  5              }
  797  4              else if((360 - f + 30 * i) < 181 )
  798  4              {
  799  5                lIndex[i] = (360 - f + 30 * i);
  800  5              }
  801  4              else
  802  4              {
  803  5                lIndex[i] = abs(360 + f - 30 * i);
  804  5              }
  805  4            }
  806  3            //–≤—ã—á–∏—Å–ª—è–µ–º —Ñ-–∏—é –ø—Ä–∞–≤–¥–æ–ø–æ–¥–æ–±–∏—è
  807  3            fLikelihoods[f] = 0;
  808  3            
  809  3            for(i = 0;i<SensCount;i++)
  810  3            {
  811  4              if(Mode == CNTR_MODE)
  812  4                fLikelihoods[f] += (pData[i] * BDGPParametrs[currentRangeIndex].fCorrectionFactors[i] * log(1 + fLog 
             -* directionCoef[lIndex[i]]) - SignalLevel * directionCoef[lIndex[i]]);
  813  4              if(Mode == SPEC_MODE)
  814  4                fLikelihoods[f] += (pData[i] * log(1 + fLog * directionCoef[lIndex[i]]) - SignalLevel * directionCoef
             -[lIndex[i]]);
  815  4            }
  816  3          }
  817  2          //–Ω–∞—Ö–æ–¥–∏–º –º–∏–Ω–∏–º—É–º 
  818  2          for(f = 0;f<360;f++)
  819  2            if(fLikelihoods[f] < fLHMin)
  820  2              fLHMin = fLikelihoods[f];
  821  2      
  822  2          //–Ω–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º—É–º
  823  2          for(f = 0;f<360;f++)
  824  2            if(fLikelihoods[f]>fLHMax)
  825  2              fLHMax = fLikelihoods[f];
  826  2            
  827  2          //–≤—ã—á–∏—Å–ª—è–µ–º Z
  828  2          fZ = (fLHMin - (1.0f - fK) * fLHMax) / (fK * fLHMin);
  829  2          //–ø–µ—Ä–µ–∫–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Å —É—á–µ—Ç–æ–º fZ
  830  2          for(f = 0;f<360;f++)
  831  2            fLikelihoods[f] = fLikelihoods[f] - fZ * fLHMin;
  832  2      
  833  2          //–Ω–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º—É–º –∏ —É–≥–æ–ª
  834  2          for(f = 0;f<360;f++)
  835  2          {
  836  3            if(fLikelihoods[f]>fLHMax){
  837  4              fLHMax = fLikelihoods[f];
  838  4              *pAngleMax = f;
  839  4            }
  840  3          }
  841  2          
  842  2      //    if(fAngleDiagramm)
  843  2            {
  844  3              
  845  3              
  846  3              for(f = 347;f<=359;f++)
  847  3                fAngleDiagramm[0] += fLikelihoods[f];
  848  3              for(f = 0;f<=13;f++)
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 15  

  849  3                fAngleDiagramm[0] += fLikelihoods[f];
  850  3              
  851  3              
  852  3              for(f = 354;f<=359;f++)
  853  3                fAngleDiagramm[1] += fLikelihoods[f];
  854  3              for(f = 0;f<=20;f++)
  855  3                fAngleDiagramm[1] += fLikelihoods[f];
  856  3              
  857  3              g = 2;
  858  3              b = 2;
  859  3              
  860  3              do
  861  3              {
  862  4                fLLSum = 0;
  863  4                
  864  4                for(f = b;f<b + 27;f++)
  865  4                {
  866  5                  fAngleDiagramm[g] += fLikelihoods[f];
  867  5                  //fLLSum += fLikelihoods[f];
  868  5                }
  869  4                //fAngleDiagramm[g] = (1 / fLHMax) * fLLSum;
  870  4                
  871  4                if(g%2 == 0)
  872  4                  b = b + 7;  //7
  873  4                else
  874  4                  b = b + 8;  //8
  875  4                
  876  4                g++;
  877  4              }
  878  3              while(g<47);
  879  3              
  880  3              
  881  3                fAngleDiagramm[47] = 0;
  882  3              for(f = 339;f<=359;f++)
  883  3                fAngleDiagramm[47] += fLikelihoods[f];
  884  3              for(f = 0;f<=5;f++)
  885  3                fAngleDiagramm[47] += fLikelihoods[f];      
  886  3              
  887  3              //–º–∞–∫—Å–∏–º—É–º —Å–∂–∞—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
  888  3              for(g = 0;g<48;g++)
  889  3                if(fAngleDiagramm[g] > fNLMax)
  890  3                  fNLMax = fAngleDiagramm[g];
  891  3              
  892  3              if(Mode == CNTR_MODE){
  893  4                
  894  4              for(i = SLIDER_SIZE - sliderMax;i < SLIDER_SIZE;i++)
  895  4                for(j = 0;j<SensCount;j++)
  896  4                  fCountersSum += BDGPData.sensorsCntQuery[i][j];
  897  4                
  898  4              fCountersSum = fCountersSum / SensCount;
  899  4                
  900  4              if(fCountersSum < (sliderMax * BDGPData.BackgroundAverageSpeed))
  901  4                  fNormizeKoef = 0.5f;
  902  4              else
  903  4                  fNormizeKoef = 1.0f - 0.5f * ( (sliderMax * BDGPData.BackgroundAverageSpeed) / fCountersSum );
  904  4              }
  905  3              if(Mode == SPEC_MODE)
  906  3                fNormizeKoef = 0.5f;
  907  3              
  908  3              for(g = 0;g<48;g++)
  909  3                fAngleDiagramm[g] = fAngleDiagramm[g] * fNormizeKoef / fNLMax;
  910  3                /*if(fNLMax == FLT_MIN)
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 16  

  911  3                  for(g = 0;g<48;g++)
  912  3                    fAngleDiagramm[g] = 1;
  913  3                else      
  914  3                  for(g = 0;g<48;g++)
  915  3                    fAngleDiagramm[g] = fAngleDiagramm[g] / fNLMax;*/
  916  3              } 
  917  2          
  918  2          
  919  2          //free(fLikelihoods);
  920  2        }
  921  1        return fAngleDiagramm;
  922  1        
  923  1      }
  924         float *BDGP_GetAngularDiagram()
  925         {
  926  1        uint8 i = 0;
  927  1        
  928  1        float cntMin = BDGP_MinSumSensData();
  929  1        float cntMax = BDGP_MaxSumSensData();
  930  1        
  931  1        float *pAngleDiagramm;  
  932  1      
  933  1          pAngleDiagramm  = (float*)BDGP_DirectionDiagramm(BDGPData.fCorrectionSumSensData, SENSORS, cntMin,cntMax,
             -&BDGPData.radiationMaximum,CNTR_MODE);
  934  1          
  935  1      
  936  1        //    memcpy(BDGPData.nLikelihoods,pAngleDiagramm,sizeof(float) * 48);
  937  1        return  pAngleDiagramm;
  938  1      
  939  1      
  940  1        //return BDGPData.nLikelihoods;
  941  1      }
  942         
  943         void  BDGP_DataArrayCorrection(uint8  oldSize)
  944         {
  945  1        /*
  946  1        1. –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ö–≤–æ—Å—Ç–∞ –º–∞—Å—Å–∏–≤–∞(—Ä–∞–∑–º–µ—Ä–æ–º oldSize) –≤ –Ω–∞—á–∞–ª–æ –º–∞—Å—Å–
             -∏–≤–∞
  947  1        2. –û–±–Ω—É–ª–µ–Ω–∏–µ –æ—Å—Ç–∞–ª—å–Ω–æ–π —á–∞—Å—Ç–∏ –º–∞—Å—Å–∏–≤–∞ —Å–æ —Å–º–µ—â–µ–Ω–∏–µ–º oldSize
  948  1        3. –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ sliderCounter –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–
             -º oldSize
  949  1        4. –°–±—Ä–æ—Å —Ñ–ª–∞–≥–∞ QuerySuccess
  950  1        */
  951  1        memcpy(&doseArray[0],&doseArray[SLIDER_SIZE - oldSize - 1],sizeof(float) * oldSize);
  952  1        memset(&doseArray[oldSize],0,sizeof(float) * (SLIDER_SIZE - oldSize));
  953  1          
  954  1        memcpy(BDGPData.sensorsCntQuery[0],BDGPData.sensorsCntQuery[SLIDER_SIZE - oldSize - 1],sizeof(float) * SE
             -NSORS * oldSize);
  955  1        memset(BDGPData.sensorsCntQuery[oldSize],0,sizeof(float) * SENSORS * (SLIDER_SIZE - oldSize));
  956  1        
  957  1          sliderCounter = oldSize;
  958  1          
  959  1          BDGPData.QuerySuccess = 0;
  960  1      }
  961         void  BDGP_BackgroundIdentification()
  962         {
  963  1        uint8 i = 0, j = 0;
  964  1        float fSum = 0;
  965  1        
  966  1      
  967  1        
  968  1          BDGPData.fQuantile = 0;
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 17  

  969  1        
  970  1          for(i = 0;i<SENSORS;i++){
  971  2            fSum += (BDGPData.fCorrectionSumSensData[i] * sliderMax);
  972  2          }
  973  1                //–±–µ—Ä—ë–º '—Ö–≤–æ—Å—Ç' –º–∞—Å—Å–∏–≤–∞, —Ç.–∫. —Ç–∞–º —Å–∞–º—ã–µ —Å–≤–µ–∂–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ú–î
             - –∏ —Å—á–µ—Ç–æ–≤
  974  1                /*for(i = SLIDER_SIZE - sliderMax;i < SLIDER_SIZE;i++){
  975  1                  for(j = 0;j<SENSORS;j++)
  976  1                    fSum += BDGPData.sensorsCntQuery[i][j];
  977  1                }*/
  978  1      
  979  1          
  980  1          BDGPData.fQuantile = (fSum - (sliderMax * BDGPData.BackgroundAverageSpeed)) / (sqrt(sliderMax * BDGPData
             -.BackgroundAverageSpeed) + 1);
  981  1        
  982  1          if(BDGPData.fQuantile > MainSettings.limitDetect[0])
  983  1          {
  984  2            //—Å—Ç–∞–≤–∏–º —Ñ–ª–∞–≥ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –Ω—É–∫–ª–∏–¥–∞
  985  2            if(!BDGPData.NuclideDetection)
  986  2              BDGPData.NuclideDetection = 1;
  987  2            
  988  2            IMDB_NuclideDetectionSignalCallback();
  989  2          }
  990  1          else
  991  1          {
  992  2            //–µ—Å–ª–∏ –±—ã–ª–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
  993  2            if(BDGPData.NuclideDetection){
  994  3              BDGPData.NuclideDetection = 0;
  995  3              IMDB_NuclideEndDetectionSignalCallback(); //—à–ª—ë–º —Å–∏–≥–Ω–∞–ª –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ
             -–Ω–∏—è –æ —Å–±—Ä–æ–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∏—Å—Ç–æ—á–Ω–∏–∫–∞
  996  3            }
  997  2          }
  998  1      }
  999         
 1000         void  BDGP_Process()
 1001         {
 1002  1        uint8     i = 0,j=0;
 1003  1        
 1004  1        
 1005  1        
 1006  1        if(BDGPData.ChangeBufferEvent == 1)
 1007  1        {
 1008  2          BDGPData.ChangeBufferEvent = 0;
 1009  2          
 1010  2          if(BDGPData.ActiveBuffer == 1)
 1011  2              memcpy(BDGPData.WorkData,BDGPData.InputData[0],sizeof(uint16) * SENSORS);
 1012  2          else
 1013  2              memcpy(BDGPData.WorkData,BDGPData.InputData[1],sizeof(uint16) * SENSORS); 
 1014  2          
 1015  2              //////////////////////////////
 1016  2              //–Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞ –¥–ª—è –ë–î–ì–ü-y–ë//
 1017  2              //////////////////////////////
 1018  2              /*
 1019  2                TO-DO —Å–¥–µ–ª–∞—Ç—å —Ä–µ–∂–∏–º –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è —Ñ–æ–Ω–∞!
 1020  2              */
 1021  2                //–≤—ã–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ —Ç–µ–∫—É—â–∏–π —Ä–∞–±–æ—á–∏–π —Å—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã
 1022  2              if(Process_GetOperationMode() == IMDB_BACKGROUND_ACCUMULATION){
 1023  3              //–∏ –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Å–ø–µ–∫—Ç—Ä–æ–º–µ—Ç—Ä–∞
 1024  3                if(Process_GetBDPSStatus() == DEVICE_NOTREADY){
 1025  4                  BDGP_BackgroundAccumulation((uint16*)BDGPData.WorkData);//–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ —Å—á–µ—Ç–æ–≤ –ø
             -—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø—Ä–∏ –ø–æ–¥—Å—á—ë—Ç–µ —Ñ–æ–Ω–æ–≤–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å—á—ë—Ç–∞
 1026  4                }
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 18  

 1027  3              }   
 1028  2          
 1029  2          
 1030  2          BDGPData.averageDose = 0;
 1031  2          //–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –¥–≤–∏–∂–æ–∫ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ä–µ–¥–Ω–µ–π –ú–î
 1032  2            if(sliderCounter<SLIDER_SIZE){
 1033  3              doseArray[sliderCounter] = BDGPData.currentDose;
 1034  3              
 1035  3              //–∑–∞–ø–æ–ª–Ω—è–µ–º –æ—á–µ—Ä–µ–¥—å —Å—á–µ—Ç–æ–≤ —Å –ø–æ–ø—Ä–∞–≤–∫–æ–π –Ω–∞ –ø–æ–ø—Ä. –∫–æ—ç—Ñ –∏ –º—ë
             -—Ä—Ç–≤–æ–µ –≤—Ä–µ–º—è
 1036  3              
 1037  3              for(i = 0;i<SENSORS;i++)
 1038  3                BDGPData.sensorsCntQuery[sliderCounter][i] = ((BDGPData.WorkData[i] * BDGPParametrs[currentRangeIndex
             -].fCorrectionFactors[i]) / (1.0f - BDGPData.WorkData[i] * BDGPParametrs[currentRangeIndex].fDeadTime));
 1039  3              
 1040  3              sliderCounter++;
 1041  3            }
 1042  2            else
 1043  2            {
 1044  3              if(!BDGPData.QuerySuccess)  //–Ω–∞–∫–æ–ø–∏–ª–∏ –æ—á–µ—Ä–µ–¥–∏ –ú–î –∏ —Å—á–µ—Ç–æ–≤
 1045  3                BDGPData.QuerySuccess = 1;
 1046  3              
 1047  3              memcpy(&doseArray[0],&doseArray[1],sizeof(float) * (SLIDER_SIZE - 1));
 1048  3              memcpy(BDGPData.sensorsCntQuery[0],BDGPData.sensorsCntQuery[1],sizeof(float) * SENSORS * (SLIDER_SIZE 
             -- 1));
 1049  3              
 1050  3              
 1051  3              doseArray[SLIDER_SIZE - 1] = BDGPData.currentDose;
 1052  3              
 1053  3              for(i = 0;i<SENSORS;i++)
 1054  3                BDGPData.sensorsCntQuery[SLIDER_SIZE - 1][i] = ((BDGPData.WorkData[i] * BDGPParametrs[currentRangeInd
             -ex].fCorrectionFactors[i]) / (1.0f - BDGPData.WorkData[i] * BDGPParametrs[currentRangeIndex].fDeadTime));
 1055  3            }
 1056  2              
 1057  2              memset(BDGPData.fCorrectionSumSensData,0,sizeof(float) * SENSORS);  //–æ—á–∏—â–∞–µ–º —É—Å—Ä–µ–¥–Ω–µ–Ω–Ω
             -—ã–π –ø–æ –¥–≤–∏–∂–∫—É –º–∞—Å—Å–∏–≤
 1058  2            
 1059  2              if(BDGPData.QuerySuccess)
 1060  2              {
 1061  3                //–µ—Å–ª–∏ –Ω–∞–∫–æ–ø–∏–ª–∏ –¥–≤–∏–∂–æ–∫ –ú–î, —Ç–æ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ —
             -Å—á—ë—Ç–∞ –ø–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –ú–î
 1062  3                
 1063  3                /*
 1064  3                  TO-DO! –ü—Ä–æ–≥—Ä–∞–º–º–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –º–∞—Å—Å–∏–≤–æ–≤ –¥–≤–∏–∂–∫–æ–≤ –≤ —Å–æ–æ—Ç
             -–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º –≤—Ä–µ–º–µ–Ω–∏—è –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è –¥–≤–∏–∂–∫–∞ –≤ –±–æ–ª—å—à—É—é —Å—Ç–æ—Ä–æ
             -–Ω—É
 1065  3                */
 1066  3                if(BDGPData.counterRate < 3){
 1067  4                  /*if(sliderMax == 10)
 1068  4                    BDGP_DataArrayCorrection(sliderMax);*/
 1069  4                  
 1070  4                  sliderMax = 30;
 1071  4                }
 1072  3                else if(BDGPData.counterRate > 1 && BDGPData.counterRate < 12){
 1073  4                  /*if(sliderMax == 2)
 1074  4                    BDGP_DataArrayCorrection(sliderMax);*/
 1075  4                  
 1076  4                  sliderMax = 10;
 1077  4                }
 1078  3                else if(BDGPData.counterRate > 8)
 1079  3                  sliderMax = 2;
 1080  3                else;
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 19  

 1081  3                //–±–µ—Ä—ë–º '—Ö–≤–æ—Å—Ç' –º–∞—Å—Å–∏–≤–∞, —Ç.–∫. —Ç–∞–º —Å–∞–º—ã–µ —Å–≤–µ–∂–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ú–î
             - –∏ —Å—á–µ—Ç–æ–≤
 1082  3                for(i = SLIDER_SIZE - sliderMax;i < SLIDER_SIZE;i++){
 1083  4                  BDGPData.averageDose += doseArray[i];
 1084  4                  for(j = 0;j<SENSORS;j++)
 1085  4                    BDGPData.fCorrectionSumSensData[j] += BDGPData.sensorsCntQuery[i][j];
 1086  4                }
 1087  3            
 1088  3                
 1089  3                BDGPData.averageDose = BDGPData.averageDose / sliderMax;
 1090  3                
 1091  3                  for(j = 0;j<SENSORS;j++)
 1092  3                    BDGPData.fCorrectionSumSensData[j] = BDGPData.fCorrectionSumSensData[j] / sliderMax;          
 1093  3              }
 1094  2              else
 1095  2              {
 1096  3                //–µ—Å–ª–∏ –Ω–µ—Ç, —Ç–æ –≤—ã–≤–æ–¥–∏–º —É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ –ø–æ —Å—á—ë—Ç—á–∏–∫—É –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—
             -è
 1097  3                for(i = 0;i<sliderCounter;i++){
 1098  4                  BDGPData.averageDose += doseArray[i];
 1099  4                  for(j = 0;j<SENSORS;j++)
 1100  4                    BDGPData.fCorrectionSumSensData[j] += BDGPData.sensorsCntQuery[i][j];
 1101  4                  
 1102  4                }
 1103  3                
 1104  3                if(sliderCounter != 0){
 1105  4                  BDGPData.averageDose = BDGPData.averageDose / sliderCounter;
 1106  4                  
 1107  4                  for(j = 0;j<SENSORS;j++)
 1108  4                    BDGPData.fCorrectionSumSensData[j] = BDGPData.fCorrectionSumSensData[j] / sliderCounter;
 1109  4                }
 1110  3              }
 1111  2              BDGPData.Dose += BDGPData.currentDose;
 1112  2              
 1113  2              //—Ñ–æ–Ω–æ–≤–∞—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
 1114  2              if(BDGPData.Background){
 1115  3                BDGP_BackgroundIdentification();
 1116  3              }
 1117  2                    
 1118  2        }
 1119  1      }
 1120         
 1121         float BDGP_GetMaximumAngle()
 1122         {
 1123  1        float fAngle = (float)BDGPData.radiationMaximum;
 1124  1        
 1125  1        return fAngle;
 1126  1      }
 1127         float BDGP_GetDose()
 1128         {
 1129  1        return BDGPData.Dose;
 1130  1      }
 1131         uint8   BDGP_GetBackgroundState()
 1132         {
 1133  1        return BDGPData.Background;
 1134  1      }
 1135         
 1136         uint8 BDGP_GetOutsideFeature()
 1137         { 
 1138  1          if(BDGPData.currentDose >= 1.3f * BDGPData.averageDose)
 1139  1            return 1; //–ú–î —É–≤–µ–ª–∏—á–∏–ª–∞—Å—å
 1140  1          else if(BDGPData.currentDose <= 0.7f * BDGPData.averageDose)
C166 COMPILER V7.53.0.0, BDGP                                                              04/17/2017 11:10:30 PAGE 20  

 1141  1            return 2; //–ú–î —É–º–µ–Ω—å—à–∏–ª–∞—Å—å
 1142  1          else
 1143  1            return 0; //–ú–î –Ω–µ–∏–∑–º–µ–Ω–∏–ª–∞—Å—å
 1144  1      }
 1145         


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        8636     --------
  NEAR-CONST SIZE  =           3     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =         724     --------
  NEAR-DATA SIZE   =           5     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =        3668     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =          30     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
